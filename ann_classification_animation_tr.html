<!DOCTYPE html>
<html lang="tr">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MNIST Yapay Sinir Ağı Animasyonu</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <!-- Syntax Highlighting için Prism.js CSS -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
  <style>
    /* Değişkenler ve Temel Ayarlar */
    :root {
      --primary-color: #3498db;
      --primary-hover: #2980b9;
      --accent-color: #ff6b6b;
      --bg-color: #f5f5f5;
      --card-bg: #ffffff;
      --text-color: #333;
      --box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      --transition-speed: 0.3s;

      /* Piksel boyutları */
      --pixel-size: 20px;
      /* Girdi rakamlarındaki piksel kutusu boyutu */
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: var(--card-bg);
      box-shadow: var(--box-shadow);
      border-radius: 10px;
      padding: 30px;
    }

    header h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 2rem;
      color: #2c3e50;
    }

    /* Girdi Rakamı Alanı */
    .input-image {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 30px;
    }

    .input-image h3 {
      margin-bottom: 12px;
      font-size: 1.3rem;
      color: #2c3e50;
    }

    .digit-grid {
      display: grid;
      grid-template-columns: repeat(7, var(--pixel-size));
      grid-template-rows: repeat(7, var(--pixel-size));
      gap: 2px;
      margin-bottom: 15px;
    }

    .pixel {
      width: var(--pixel-size);
      height: var(--pixel-size);
      background-color: #ddd;
      border-radius: 2px;
    }

    .pixel.active {
      background-color: #333;
    }

    .current-digit {
      font-size: 2.2rem;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Ağ (Katmanlar) Alanı */
    .network-container {
      position: relative;
      height: 500px;
      margin: 40px 0;
    }

    .layer {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
    }

    .layer-info {
      background-color: rgba(240, 240, 240, 0.9);
      border-radius: 5px;
      padding: 8px 12px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .neurons-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: rgba(240, 240, 240, 0.8);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
    }

    .neuron {
      width: 18px;
      height: 18px;
      margin: 3px;
      border-radius: 50%;
      background-color: #e0e0e0;
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }

    .neuron.active {
      background-color: var(--accent-color);
      transform: scale(1.3);
    }

    .neuron.input {
      background-color: #74b9ff;
    }

    .neuron.output {
      background-color: #55efc4;
    }

    .activation-function {
      margin-top: 5px;
      font-size: 0.9rem;
      font-weight: 600;
      opacity: 0.8;
    }

    /* Katmanlar arası bağlantılar (SVG) */
    .svg-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .connection {
      stroke: #999;
      stroke-opacity: 0.1;
      transition: stroke var(--transition-speed), stroke-opacity var(--transition-speed);
    }

    .connection.active {
      stroke: var(--accent-color);
      stroke-opacity: 0.7;
      stroke-width: 1.5;
    }

    /* Çıktı Gösterimi */
    .output-display {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      position: relative;
      margin-top: 30px;
    }

    .digit-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .output-digit {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 1rem;
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }

    .output-digit.active {
      background-color: var(--accent-color);
      color: #fff;
      transform: scale(1.2);
    }

    .probability-bar {
      width: 40px;
      background-color: #e0e0e0;
      transition: height 0.5s, background-color 0.5s;
      margin-top: 5px;
    }

    .probability-bar.active {
      background-color: var(--accent-color);
    }

    .probability-value {
      font-size: 0.9rem;
      margin-top: 5px;
      font-weight: 500;
    }

    /* Tahmin Sonucu */
    .prediction-result {
      text-align: center;
      font-size: 1.4rem;
      font-weight: 600;
      padding: 18px;
      background-color: #f0f8ff;
      border-radius: 8px;
      margin-top: 40px;
      opacity: 0;
      transition: opacity 1s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .prediction-result.show {
      opacity: 1;
    }

    .result-overlay {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 3rem;
      font-weight: 700;
      color: var(--accent-color);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      animation: popIn 0.5s ease-out;
    }

    @keyframes popIn {
      0% {
        transform: scale(0);
        opacity: 0;
      }

      60% {
        transform: scale(1.2);
        opacity: 1;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Kontrol Paneli (Butonlar) */
    .control-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-top: 40px;
    }

    button {
      padding: 12px 28px;
      background-color: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color var(--transition-speed), transform 0.2s;
      font-weight: 600;
    }

    button:hover {
      background-color: var(--primary-hover);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(1px);
    }

    /* Açıklama Bölümü */
    .explanation {
      margin-top: 40px;
      padding: 25px;
      background-color: #f5f9fc;
      border-radius: 10px;
      line-height: 1.7;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .explanation h3 {
      margin-bottom: 15px;
      font-size: 1.4rem;
      color: #2c3e50;
      border-bottom: 2px solid #e1e8ed;
      padding-bottom: 8px;
    }

    .explanation p {
      margin-bottom: 15px;
    }

    .explanation ul {
      margin-bottom: 15px;
      padding-left: 25px;
    }

    .explanation li {
      margin-bottom: 8px;
    }

    /* Ek başlıklar için */
    .explanation h4 {
      margin-top: 30px;
      margin-bottom: 15px;
      font-size: 1.2rem;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Python kod bloğu için özel stiller */
    pre[class*="language-"] {
      margin: 20px 0;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    code[class*="language-"] {
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .token.comment {
      color: #75715e;
      font-style: italic;
    }

    .token.keyword {
      color: #f92672;
    }

    .token.string {
      color: #a6e22e;
    }

    .token.function {
      color: #66d9ef;
    }

    .token.class-name {
      color: #a6e22e;
    }

    /* Footer */
    footer p {
      text-align: center;
      font-size: 0.9rem;
      opacity: 0.8;
      margin-top: 40px;
      padding-top: 15px;
      border-top: 1px solid #e1e8ed;
    }

    /* Python açıklamalarını vurgulama için */
    .code-comment {
      color: #6a9955;
      font-style: italic;
    }

    .highlight {
      background-color: rgba(255, 255, 0, 0.1);
      padding: 1px 2px;
      border-radius: 3px;
    }

    /* Duyarlı tasarım (responsive design) */
    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }

      header h1 {
        font-size: 1.6rem;
      }

      .explanation {
        padding: 15px;
      }

      pre[class*="language-"] {
        font-size: 0.85rem;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>MNIST Yapay Sinir Ağı Animasyonu</h1>
    </header>

    <main>
      <!-- Girdi Rakamı -->
      <section class="input-image">
        <h3>Girdi Rakamı</h3>
        <div class="digit-grid" id="digitGrid"></div>
        <div class="current-digit" id="currentDigit">3</div>
      </section>

      <!-- Ağ Yapısı (Katmanlar + Bağlantılar) -->
      <section class="network-container" id="networkContainer">
        <div class="svg-container" id="svgContainer">
          <svg id="connectionsSvg"></svg>
        </div>
        <!-- Katmanlar JS ile dinamik olarak eklenecek -->
      </section>

      <!-- Çıktı Gösterimi -->
      <section class="output-display" id="outputDisplay">
        <!-- 0-9 arasındaki çıktı rakamları ve olasılık çubukları JS ile eklenecek -->
      </section>

      <!-- Tahmin Sonucu -->
      <section id="predictionResult" class="prediction-result">
        Tahmin: <span id="predictedDigit">3</span> (Güven: <span id="confidence">92%</span>)
      </section>

      <!-- Kontrol Butonları -->
      <section class="control-panel">
        <button id="restartBtn">Animasyonu Yeniden Başlat</button>
        <button id="changeDigitBtn">Rakamı Değiştir</button>
      </section>

      <!-- Açıklama ve Yeni Chapter -->
      <section class="explanation">
        <h3>MNIST Yapay Sinir Ağı Nasıl Çalışır?</h3>
        <p>Bu animasyon, yapay sinir ağının bir el yazısı rakamı nasıl tanıdığını göstermektedir. Model 4 katmandan
          oluşur:</p>
        <ul>
          <li><strong>Girdi Katmanı:</strong> 28x28 piksellik el yazısı görüntüsü 784 nöronluk bir vektöre dönüştürülür.
          </li>
          <li><strong>Gizli Katmanlar:</strong> Sırasıyla 512, 256 ve 128 nöron içerir ve her katman bir önceki
            katmandan gelen bilgiyi işler.</li>
          <li><strong>Çıktı Katmanı:</strong> 10 nöron içerir ve her biri 0-9 rakamını temsil eder.</li>
        </ul>
        <p>Her katman arasında <strong>ReLU</strong>, son katmanda ise <strong>log_softmax</strong> aktivasyon
          fonksiyonu kullanılır. <em>log_softmax</em>, softmax fonksiyonunun logaritmasıdır. Softmax fonksiyonu
          çıktıları 0 ile 1 arasında olasılık değerlerine dönüştürür ve bunların toplamı 1'e eşittir. Bu işlem hangi
          rakamın en yüksek olasılığa sahip olduğunu belirlemek için kullanılır.</p>
        <p>Animasyonda aktif nöronlar kırmızı renkle, önemli bağlantılar vurgulanarak gösterilir. Ayrıca her rakamın
          olasılığı bir çubukla temsil edilir ve en yüksek olasılığa sahip rakam "tahmin" olarak gösterilir.</p>

        <!-- Yeni Chapter: Python Kod ve Açıklamaları -->
        <h4>Python Kod ve Açıklamaları</h4>
        <p>Aşağıda, PyTorch ile yazılmış basit bir tam bağlantılı sinir ağı (MNISTNet) örneği ve satır içi açıklamaları
          yer almaktadır. Bu kod, 28x28 boyutundaki MNIST görüntülerini (784 piksel) giriş olarak alır, üç gizli
          katmandan geçirir ve 10 farklı rakam (0-9) için logaritmik olasılık değerleri döndürür.</p>

        <pre><code class="language-python">import torch
import torch.nn as nn           # PyTorch'un temel sinir ağı modülleri
import torch.nn.functional as F # Aktivasyon fonksiyonları ve diğer yardımcı işlevler

class MNISTNet(nn.Module):
    """
    MNISTNet, MNIST veri kümesi için tasarlanmış basit bir tam bağlantılı (fully connected)
    yapay sinir ağı mimarisidir.
    """
    def __init__(self):
        # nn.Module sınıfının başlatıcısını çağırıyoruz
        super(MNISTNet, self).__init__()

        # Girdi katmanı: 28x28 piksel -> 784 boyutunda vektör
        # 1. Gizli katman: 784 -> 512
        self.fc1 = nn.Linear(784, 512)

        # 2. Gizli katman: 512 -> 256
        self.fc2 = nn.Linear(512, 256)

        # 3. Gizli katman: 256 -> 128
        self.fc3 = nn.Linear(256, 128)

        # Çıktı katmanı: 128 -> 10 (0'dan 9'a kadar rakam sınıfları)
        self.fc4 = nn.Linear(128, 10)

        # Overfitting'i azaltmak için Dropout katmanı (örnekleme oranı %20)
        self.dropout = nn.Dropout(0.2)

    def forward(self, x):
        """
        İleri yayılım (forward pass) metodunda verinin ağa hangi sırayla aktarılacağını tanımlarız.
        x: [batch_size, 1, 28, 28] şeklinde gelen MNIST görüntüleri
        """
        # 1) Girdi verisini düzleştiriyoruz: [batch_size, 784]
        x = x.view(-1, 28 * 28)

        # 2) İlk katman + ReLU aktivasyonu
        x = F.relu(self.fc1(x))
        # Dropout uygulayarak belirli nöronları devre dışı bırakıyoruz
        x = self.dropout(x)

        # 3) İkinci katman + ReLU aktivasyonu
        x = F.relu(self.fc2(x))
        x = self.dropout(x)

        # 4) Üçüncü katman + ReLU aktivasyonu
        x = F.relu(self.fc3(x))
        x = self.dropout(x)

        # 5) Çıktı katmanı
        x = self.fc4(x)

        # 6) log_softmax ile çıktı değerlerini olasılık dağılımına dönüştürüyoruz
        # dim=1: satır bazında (her örnek için) log_softmax hesaplar
        return F.log_softmax(x, dim=1)</code></pre>

        <p>Bu modelin eğitimi sırasında, çapraz entropi benzeri bir kayıp fonksiyonu (örn. <code>nn.NLLLoss</code> veya
          <code>nn.CrossEntropyLoss</code>) kullanılır. Eğitim tamamlandığında, model her girdi görüntü için bir
          "tahmin" (en yüksek olasılığa sahip rakam) üretir.</p>
      </section>
    </main>

    <footer>
      <p>© 2025 MNIST Animasyon Örneği</p>
    </footer>
  </div>

  <!-- Prism.js için CSS ve JS -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

  <script>
    // Sayfa tamamen yüklendikten sonra çalışacak kod
    window.onload = function () {
      // Ağ yapılandırması
      const networkConfig = {
        layers: [
          { name: "Girdi (784)", neurons: 10, fullSize: 784, activationFunc: "" },
          { name: "Gizli 1 (512)", neurons: 8, fullSize: 512, activationFunc: "ReLU" },
          { name: "Gizli 2 (256)", neurons: 6, fullSize: 256, activationFunc: "ReLU" },
          { name: "Gizli 3 (128)", neurons: 5, fullSize: 128, activationFunc: "ReLU" },
          { name: "Çıktı (10)", neurons: 10, fullSize: 10, activationFunc: "log_softmax" }
        ]
      };

      // Örnek rakamlar
      const sampleDigits = [3, 7, 2, 5, 0, 1, 9, 8];
      let currentDigitIndex = 0;

      // 7x7 piksel paternleri
      const digitPatterns = {
        0: [
          [0, 1, 1, 1, 1, 1, 0],
          [1, 1, 0, 0, 0, 1, 1],
          [1, 1, 0, 0, 0, 1, 1],
          [1, 1, 0, 0, 0, 1, 1],
          [1, 1, 0, 0, 0, 1, 1],
          [1, 1, 0, 0, 0, 1, 1],
          [0, 1, 1, 1, 1, 1, 0]
        ],
        1: [
          [0, 0, 1, 1, 0, 0, 0],
          [0, 1, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ],
        2: [
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 1, 1, 0, 0, 0, 0],
          [1, 1, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 0]
        ],
        3: [
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ],
        5: [
          [1, 1, 1, 1, 1, 1, 0],
          [1, 1, 0, 0, 0, 0, 0],
          [1, 1, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ],
        7: [
          [1, 1, 1, 1, 1, 1, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [0, 0, 0, 1, 1, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 1, 1, 0, 0, 0, 0],
          [0, 1, 1, 0, 0, 0, 0],
          [0, 1, 1, 0, 0, 0, 0]
        ],
        8: [
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ],
        9: [
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 1, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ]
      };

      // DOM referansları
      const digitGrid = document.getElementById('digitGrid');
      const currentDigitElem = document.getElementById('currentDigit');
      const outputDisplay = document.getElementById('outputDisplay');
      const networkContainer = document.getElementById('networkContainer');
      const restartBtn = document.getElementById('restartBtn');
      const changeDigitBtn = document.getElementById('changeDigitBtn');

      let connections = [];
      let animationTimeouts = [];

      /* ========== Girdi Rakamı (7x7 Piksel) ========== */
      function createDigitGrid() {
        digitGrid.innerHTML = '';
        const digit = sampleDigits[currentDigitIndex];
        const pattern = digitPatterns[digit];
        for (let i = 0; i < 7; i++) {
          for (let j = 0; j < 7; j++) {
            const pixel = document.createElement('div');
            pixel.className = 'pixel';
            if (pattern[i][j] === 1) {
              pixel.classList.add('active');
            }
            digitGrid.appendChild(pixel);
          }
        }
        currentDigitElem.textContent = digit;
      }

      /* ========== Çıktı (Olasılıklar) ========== */
      function createOutputDisplay() {
        outputDisplay.innerHTML = '';
        for (let i = 0; i < 10; i++) {
          const digitContainer = document.createElement('div');
          digitContainer.className = 'digit-container';

          const digitElem = document.createElement('div');
          digitElem.className = 'output-digit';
          digitElem.id = `output-${i}`;
          digitElem.textContent = i;
          digitContainer.appendChild(digitElem);

          const probBar = document.createElement('div');
          probBar.className = 'probability-bar';
          probBar.id = `prob-bar-${i}`;
          digitContainer.appendChild(probBar);

          const probValue = document.createElement('div');
          probValue.className = 'probability-value';
          probValue.id = `prob-value-${i}`;
          probValue.textContent = '0%';
          digitContainer.appendChild(probValue);

          outputDisplay.appendChild(digitContainer);
        }
      }

      /* ========== Ağ Oluşturma (Katmanlar + Bağlantılar) ========== */
      function createNeuralNetwork() {
        networkContainer.innerHTML = '';

        // SVG için kapsayıcı
        const svgContainer = document.createElement('div');
        svgContainer.className = 'svg-container';
        svgContainer.id = 'svgContainer';
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'connectionsSvg';
        svgContainer.appendChild(svg);
        networkContainer.appendChild(svgContainer);

        // Katmanları yerleştirme
        networkConfig.layers.forEach((layerConfig, layerIndex) => {
          const layer = document.createElement('div');
          layer.className = 'layer';
          layer.id = `layer-${layerIndex}`;

          // Katmanları yatayda eşit aralıkla konumlandırma
          const containerWidth = networkContainer.clientWidth;
          const layerSpacing = containerWidth / (networkConfig.layers.length + 1);
          layer.style.left = `${layerSpacing * (layerIndex + 1)}px`;

          // Katman başlığı
          const layerInfo = document.createElement('div');
          layerInfo.className = 'layer-info';
          layerInfo.textContent = layerConfig.name;
          layer.appendChild(layerInfo);

          // Nöronlar
          const neuronsContainer = document.createElement('div');
          neuronsContainer.className = 'neurons-container';
          for (let i = 0; i < layerConfig.neurons; i++) {
            const neuron = document.createElement('div');
            neuron.className = 'neuron';
            neuron.id = `neuron-${layerIndex}-${i}`;
            if (layerIndex === 0) {
              neuron.classList.add('input');
            } else if (layerIndex === networkConfig.layers.length - 1) {
              neuron.classList.add('output');
            }
            neuronsContainer.appendChild(neuron);
          }
          layer.appendChild(neuronsContainer);

          // Aktivasyon fonksiyonu etiketi
          if (layerConfig.activationFunc && layerConfig.activationFunc !== "log_softmax") {
            const activation = document.createElement('div');
            activation.className = 'activation-function';
            activation.textContent = layerConfig.activationFunc;
            layer.appendChild(activation);
          }

          networkContainer.appendChild(layer);
        });
        // Bağlantıları oluştur
        createConnections();
      }

      function createConnections() {
        const svg = document.getElementById('connectionsSvg');
        svg.innerHTML = '';
        connections = [];

        for (let l = 0; l < networkConfig.layers.length - 1; l++) {
          const sourceLayer = document.getElementById(`layer-${l}`);
          const targetLayer = document.getElementById(`layer-${l + 1}`);
          const sourceNeurons = sourceLayer.querySelectorAll('.neuron');
          const targetNeurons = targetLayer.querySelectorAll('.neuron');

          sourceNeurons.forEach((sourceNeuron, si) => {
            const sourceRect = sourceNeuron.getBoundingClientRect();
            const containerRect = networkContainer.getBoundingClientRect();

            targetNeurons.forEach((targetNeuron, ti) => {
              const targetRect = targetNeuron.getBoundingClientRect();
              const x1 = sourceRect.left + sourceRect.width / 2 - containerRect.left;
              const y1 = sourceRect.top + sourceRect.height / 2 - containerRect.top;
              const x2 = targetRect.left + targetRect.width / 2 - containerRect.left;
              const y2 = targetRect.top + targetRect.height / 2 - containerRect.top;

              const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              line.setAttribute('x1', x1);
              line.setAttribute('y1', y1);
              line.setAttribute('x2', x2);
              line.setAttribute('y2', y2);
              line.setAttribute('class', 'connection');
              line.id = `connection-${l}-${si}-${l + 1}-${ti}`;
              svg.appendChild(line);

              connections.push({
                sourceLayer: l,
                sourceNeuron: si,
                targetLayer: l + 1,
                targetNeuron: ti,
                element: line
              });
            });
          });
        }
      }

      /* ========== Animasyon (İleri Yayılım) ========== */
      function runForwardPassAnimation() {
        clearActivations();

        const neuronDelay = 400;
        const layerDelay = 800;
        const inputNeurons = document.querySelectorAll('#layer-0 .neuron');
        const currentDigit = sampleDigits[currentDigitIndex];

        // Girdi katmanı aktivasyonu
        setTimeout(() => {
          const activeNeuronCount = Math.floor(Math.random() * 2) + 3;
          const activeIndices = new Set();
          while (activeIndices.size < activeNeuronCount) {
            const randIndex = Math.floor(Math.random() * inputNeurons.length);
            activeIndices.add(randIndex);
          }
          activeIndices.forEach(idx => {
            inputNeurons[idx].classList.add('active');
          });
        }, 500);

        // Katmanlar arası geçiş
        for (let l = 0; l < networkConfig.layers.length - 1; l++) {
          setTimeout(() => {
            const sourceNeurons = document.querySelectorAll(`#layer-${l} .neuron.active`);
            const targetLayer = l + 1;

            sourceNeurons.forEach(sourceNeuron => {
              const sourceIndex = parseInt(sourceNeuron.id.split('-')[2]);
              const relevantConnections = connections.filter(
                conn => conn.sourceLayer === l && conn.sourceNeuron === sourceIndex
              );
              relevantConnections.forEach(conn => {
                conn.element.classList.add('active');
              });

              // Rastgele hedef nöron aktivasyonu
              setTimeout(() => {
                const targetNeurons = document.querySelectorAll(`#layer-${targetLayer} .neuron`);
                const neuronCount = Math.min(targetNeurons.length, Math.floor(Math.random() * 2) + 2);
                const activeIndices = new Set();
                while (activeIndices.size < neuronCount) {
                  const randIndex = Math.floor(Math.random() * targetNeurons.length);
                  activeIndices.add(randIndex);
                }
                activeIndices.forEach(idx => {
                  targetNeurons[idx].classList.add('active');
                });
              }, neuronDelay);
            });
          }, layerDelay * (l + 1));
        }

        // Son katman (softmax sonuçları)
        setTimeout(() => {
          const probabilities = generateSoftmaxProbabilities(currentDigit);
          updateProbabilityBars(probabilities);

          const predictedDigit = currentDigit;
          const outputDigit = document.getElementById(`output-${predictedDigit}`);
          if (outputDigit) {
            outputDigit.classList.add('active');
          }
          const lastLayerIndex = networkConfig.layers.length - 1;
          const allOutputNeurons = document.querySelectorAll(`#layer-${lastLayerIndex} .neuron`);
          allOutputNeurons.forEach(neuron => {
            neuron.classList.add('output');
          });
          const outputNeuron = document.getElementById(`neuron-${lastLayerIndex}-${predictedDigit}`);
          if (outputNeuron) {
            outputNeuron.classList.add('active');
            outputNeuron.classList.remove('output');
          }
          document.getElementById('predictedDigit').textContent = predictedDigit;
          document.getElementById('confidence').textContent = `${Math.round(probabilities[predictedDigit] * 100)}%`;
          document.getElementById('predictionResult').classList.add('show');

          const resultOverlay = document.createElement('div');
          resultOverlay.className = 'result-overlay';
          resultOverlay.textContent = predictedDigit;
          networkContainer.appendChild(resultOverlay);
        }, layerDelay * networkConfig.layers.length);
      }

      /* ========== Softmax Simülasyonu ========== */
      function generateSoftmaxProbabilities(correctDigit) {
        const probabilities = Array(10).fill(0).map(() => Math.random() * 0.1);
        probabilities[correctDigit] = 0.7 + Math.random() * 0.25;
        const sum = probabilities.reduce((a, b) => a + b, 0);
        return probabilities.map(p => p / sum);
      }

      function updateProbabilityBars(probabilities) {
        probabilities.forEach((prob, index) => {
          const bar = document.getElementById(`prob-bar-${index}`);
          const value = document.getElementById(`prob-value-${index}`);
          if (bar && value) {
            const height = prob * 100;
            bar.style.height = `${height}px`;
            value.textContent = `${Math.round(prob * 100)}%`;
            if (prob > 0.1) {
              bar.classList.add('active');
            } else {
              bar.classList.remove('active');
            }
          }
        });
      }

      /* ========== Temizleme ========== */
      function clearActivations() {
        document.querySelectorAll('.neuron').forEach(neuron => {
          neuron.classList.remove('active');
        });
        document.querySelectorAll('.connection').forEach(conn => {
          conn.classList.remove('active');
        });
        document.querySelectorAll('.output-digit').forEach(digit => {
          digit.classList.remove('active');
        });
        document.querySelectorAll('.probability-bar').forEach(bar => {
          bar.style.height = '0';
          bar.classList.remove('active');
        });
        document.querySelectorAll('.probability-value').forEach(value => {
          value.textContent = '0%';
        });
        document.getElementById('predictionResult').classList.remove('show');
        const resultOverlay = document.querySelector('.result-overlay');
        if (resultOverlay) {
          resultOverlay.remove();
        }
        animationTimeouts.forEach(timeout => clearTimeout(timeout));
        animationTimeouts = [];
      }

      /* ========== Event Listeners ========== */
      window.addEventListener('resize', createConnections);

      restartBtn.addEventListener('click', () => {
        clearActivations();
        setTimeout(runForwardPassAnimation, 100);
      });

      changeDigitBtn.addEventListener('click', () => {
        currentDigitIndex = (currentDigitIndex + 1) % sampleDigits.length;
        createDigitGrid();
        clearActivations();
        setTimeout(runForwardPassAnimation, 300);
      });

      // Kod vurgulaması için Prism.js'i çalıştır
      if (typeof Prism !== 'undefined') {
        Prism.highlightAll();
      }

      // Sayfa başlangıcında animasyonu oluştur ve başlat
      createNeuralNetwork();
      createDigitGrid();
      createOutputDisplay();

      // Animasyonu başlat
      setTimeout(runForwardPassAnimation, 1000);
    };
  </script>
</body>

</html>