<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gradient Descent Algorithm Tutorial</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }
        h1, h2, h3 {
            color: #2c3e50;
        }
        pre {
            background-color: #f5f5f5;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
        }
        .container {
            display: flex;
            gap: 20px;
            margin: 30px 0;
        }
        .chart-container {
            flex: 1;
            height: 400px;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 10px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 20px 0;
        }
        button {
            padding: 8px 16px;
            background-color: #3498db;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #2980b9;
        }
        input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
        .highlight {
            background-color: #fffde7;
        }
        #iterations-table {
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>Gradient Descent Algorithm Visualization</h1>
    
    <p>This tutorial visualizes the gradient descent algorithm for finding the minimum of a quadratic function. The example is based on the data shown in the spreadsheet, which demonstrates how gradient descent iteratively approaches the optimal solution.</p>
    
    <div class="container">
        <div class="chart-container" id="loss-chart"></div>
        <div class="chart-container" id="function-chart"></div>
    </div>
    
    <div class="controls">
        <button id="run-btn">Run Gradient Descent</button>
        <button id="reset-btn">Reset</button>
        <div>
            <label for="learning-rate">Learning Rate:</label>
            <input type="number" id="learning-rate" min="0.01" max="1" step="0.01" value="0.01">
        </div>
        <div>
            <label for="iterations">Max Iterations:</label>
            <input type="number" id="iterations" min="1" max="100" value="35">
        </div>
    </div>
    
    <h2>Current Parameters</h2>
    <div id="parameters">
        <p>Weight (W): <span id="current-w">0</span></p>
        <p>Loss L(W): <span id="current-loss">0</span></p>
        <p>Gradient dL/dW: <span id="current-gradient">0</span></p>
        <p>Iteration: <span id="current-iteration">0</span></p>
    </div>
    
    <h2>Iterations Log</h2>
    <div id="iterations-table">
        <table>
            <thead>
                <tr>
                    <th>Iteration</th>
                    <th>Weight (W)</th>
                    <th>Loss L(W)</th>
                    <th>Gradient dL/dW</th>
                    <th>|dL/dW|</th>
                </tr>
            </thead>
            <tbody id="iterations-log">
                <!-- Will be populated by JavaScript -->
            </tbody>
        </table>
    </div>
    
    <h2>How Gradient Descent Works</h2>
    
    <p>Gradient descent is an optimization algorithm used to minimize a function by iteratively moving in the direction of steepest descent as defined by the negative of the gradient.</p>
    
    <h3>The Algorithm:</h3>
    <ol>
        <li>Start with an initial parameter value (weight)</li>
        <li>Calculate the gradient (derivative) of the loss function with respect to the parameter</li>
        <li>Update the parameter by moving in the opposite direction of the gradient</li>
        <li>Repeat until convergence</li>
    </ol>
    
    <h3>Implementation in JavaScript:</h3>
    <pre><code>// Function we want to minimize: L(W) = 5*(W-14)^2+10
function lossFunction(w) {
    return 5 * Math.pow(w - 14, 2) + 10;
}

// Derivative of the loss function: dL/dW = 10*(W-14)
function gradientFunction(w) {
    return 10 * (w - 14);
}

function gradientDescent(initialW, learningRate, maxIterations) {
    let w = initialW;
    let iterations = [];
    
    for (let i = 0; i < maxIterations; i++) {
        // Calculate current loss and gradient
        let loss = lossFunction(w);
        let gradient = gradientFunction(w);
        
        // Store current state
        iterations.push({
            iteration: i,
            w: w,
            loss: loss,
            gradient: gradient,
            absGradient: Math.abs(gradient)
        });
        
        // Stop if gradient is very small (convergence)
        if (Math.abs(gradient) < 0.001) {
            break;
        }
        
        // Update weight by moving in the opposite direction of the gradient
        w = w - learningRate * gradient;
    }
    
    return iterations;
}</code></pre>

    <h3>The Math Behind Our Example</h3>
    <p>In our example, we're minimizing the function:</p>
    <p><strong>L(W) = 5*(W-14)²+10</strong></p>
    
    <p>The derivative (gradient) is:</p>
    <p><strong>dL/dW = 10*(W-14)</strong></p>
    
    <p>For gradient descent, we update W using the rule:</p>
    <p><strong>W_{new} = W_{old} - learning_rate * gradient</strong></p>
    
    <p>This function has its minimum at W = 14, where the derivative equals zero:</p>
    <p><strong>10*(W-14) = 0</strong> gives <strong>W = 14</strong></p>
    
    <p>The gradient descent algorithm should converge to this value.</p>
    
    <script>
        // The loss function: L(W) = 5*(W-14)^2+10
        function lossFunction(w) {
            return 5 * Math.pow(w - 14, 2) + 10;
        }
        
        // Derivative of the loss function: dL/dW = 10*(W-14)
        function gradientFunction(w) {
            return 10 * (w - 14);
        }
        
        // Gradient descent implementation
        function gradientDescent(initialW, learningRate, maxIterations) {
            let w = initialW;
            let iterations = [];
            
            for (let i = 0; i < maxIterations; i++) {
                // Calculate current loss and gradient
                let loss = lossFunction(w);
                let gradient = gradientFunction(w);
                
                // Store current state
                iterations.push({
                    iteration: i,
                    w: w,
                    loss: loss,
                    gradient: gradient,
                    absGradient: Math.abs(gradient)
                });
                
                // Stop if gradient is very small (convergence)
                if (Math.abs(gradient) < 0.001) {
                    break;
                }
                
                // Update weight by moving in the opposite direction of the gradient
                w = w - learningRate * gradient;
            }
            
            return iterations;
        }
        
        // For drawing charts
        function drawLossChart(iterations, currentIndex = -1) {
            const canvas = document.getElementById('loss-chart');
            canvas.innerHTML = '';
            
            // Get data for chart
            const data = iterations.map(it => ({x: it.iteration, y: it.loss}));
            
            // Find min and max values for scaling
            const maxLoss = Math.max(...data.map(d => d.y));
            const minLoss = Math.min(...data.map(d => d.y));
            const padding = 20;
            const width = canvas.clientWidth - 2 * padding;
            const height = canvas.clientHeight - 2 * padding;
            
            // Create SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', canvas.clientWidth);
            svg.setAttribute('height', canvas.clientHeight);
            canvas.appendChild(svg);
            
            // Create title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', canvas.clientWidth / 2);
            title.setAttribute('y', padding);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-weight', 'bold');
            title.textContent = 'Loss vs. Iterations';
            svg.appendChild(title);
            
            // Scale functions
            const scaleX = (x) => padding + (x / (data.length - 1)) * width;
            const scaleY = (y) => canvas.clientHeight - padding - ((y - minLoss) / (maxLoss - minLoss)) * height;
            
            // Create line
            let pathData = '';
            data.forEach((point, i) => {
                const command = i === 0 ? 'M' : 'L';
                pathData += `${command}${scaleX(point.x)},${scaleY(point.y)} `;
            });
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', '#3498db');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            svg.appendChild(path);
            
            // Add points
            data.forEach((point, i) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', scaleX(point.x));
                circle.setAttribute('cy', scaleY(point.y));
                circle.setAttribute('r', i === currentIndex ? '6' : '4');
                circle.setAttribute('fill', i === currentIndex ? 'red' : '#3498db');
                svg.appendChild(circle);
            });
            
            // Add axes
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', padding);
            xAxis.setAttribute('y1', canvas.clientHeight - padding);
            xAxis.setAttribute('x2', canvas.clientWidth - padding);
            xAxis.setAttribute('y2', canvas.clientHeight - padding);
            xAxis.setAttribute('stroke', 'black');
            xAxis.setAttribute('stroke-width', '1');
            svg.appendChild(xAxis);
            
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', padding);
            yAxis.setAttribute('y1', padding);
            yAxis.setAttribute('x2', padding);
            yAxis.setAttribute('y2', canvas.clientHeight - padding);
            yAxis.setAttribute('stroke', 'black');
            yAxis.setAttribute('stroke-width', '1');
            svg.appendChild(yAxis);
            
            // Add labels
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', canvas.clientWidth / 2);
            xLabel.setAttribute('y', canvas.clientHeight - 5);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.textContent = 'Iterations';
            svg.appendChild(xLabel);
            
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', 5);
            yLabel.setAttribute('y', canvas.clientHeight / 2);
            yLabel.setAttribute('text-anchor', 'start');
            yLabel.setAttribute('transform', `rotate(-90, 5, ${canvas.clientHeight / 2})`);
            yLabel.setAttribute('transform-origin', `5 ${canvas.clientHeight / 2}`);
            yLabel.textContent = 'Loss L(W)';
            svg.appendChild(yLabel);
        }
        
        function drawFunctionChart(iterations, currentIndex = -1) {
            const canvas = document.getElementById('function-chart');
            canvas.innerHTML = '';
            
            const padding = 20;
            const width = canvas.clientWidth - 2 * padding;
            const height = canvas.clientHeight - 2 * padding;
            
            // Create SVG element
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('width', canvas.clientWidth);
            svg.setAttribute('height', canvas.clientHeight);
            canvas.appendChild(svg);
            
            // Create title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', canvas.clientWidth / 2);
            title.setAttribute('y', padding);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-weight', 'bold');
            title.textContent = 'Loss Function L(W) = 5*(W-14)²+10';
            svg.appendChild(title);
            
            // Draw the function
            const minW = -5;
            const maxW = 15;
            const points = [];
            const step = (maxW - minW) / 100;
            
            for (let w = minW; w <= maxW; w += step) {
                points.push({
                    w: w,
                    loss: lossFunction(w)
                });
            }
            
            // Find min and max loss values
            const maxLoss = Math.max(...points.map(p => p.loss));
            const minLoss = Math.min(...points.map(p => p.loss));
            
            // Scale functions
            const scaleX = (w) => padding + ((w - minW) / (maxW - minW)) * width;
            const scaleY = (loss) => canvas.clientHeight - padding - ((loss - minLoss) / (maxLoss - minLoss)) * height;
            
            // Create function line
            let pathData = '';
            points.forEach((point, i) => {
                const command = i === 0 ? 'M' : 'L';
                pathData += `${command}${scaleX(point.w)},${scaleY(point.loss)} `;
            });
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', pathData);
            path.setAttribute('stroke', '#3498db');
            path.setAttribute('stroke-width', '2');
            path.setAttribute('fill', 'none');
            svg.appendChild(path);
            
            // Add gradient descent points
            iterations.forEach((it, i) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', scaleX(it.w));
                circle.setAttribute('cy', scaleY(it.loss));
                circle.setAttribute('r', i === currentIndex ? '6' : '4');
                circle.setAttribute('fill', i === currentIndex ? 'red' : '#e74c3c');
                svg.appendChild(circle);
                
                // Draw lines between points
                if (i > 0) {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', scaleX(iterations[i-1].w));
                    line.setAttribute('y1', scaleY(iterations[i-1].loss));
                    line.setAttribute('x2', scaleX(it.w));
                    line.setAttribute('y2', scaleY(it.loss));
                    line.setAttribute('stroke', '#e74c3c');
                    line.setAttribute('stroke-width', '1');
                    line.setAttribute('stroke-dasharray', '4');
                    svg.appendChild(line);
                }
            });
            
            // Add axes
            const xAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            xAxis.setAttribute('x1', padding);
            xAxis.setAttribute('y1', canvas.clientHeight - padding);
            xAxis.setAttribute('x2', canvas.clientWidth - padding);
            xAxis.setAttribute('y2', canvas.clientHeight - padding);
            xAxis.setAttribute('stroke', 'black');
            xAxis.setAttribute('stroke-width', '1');
            svg.appendChild(xAxis);
            
            const yAxis = document.createElementNS('http://www.w3.org/2000/svg', 'line');
            yAxis.setAttribute('x1', padding);
            yAxis.setAttribute('y1', padding);
            yAxis.setAttribute('x2', padding);
            yAxis.setAttribute('y2', canvas.clientHeight - padding);
            yAxis.setAttribute('stroke', 'black');
            yAxis.setAttribute('stroke-width', '1');
            svg.appendChild(yAxis);
            
            // Add labels
            const xLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            xLabel.setAttribute('x', canvas.clientWidth / 2);
            xLabel.setAttribute('y', canvas.clientHeight - 5);
            xLabel.setAttribute('text-anchor', 'middle');
            xLabel.textContent = 'Weight (W)';
            svg.appendChild(xLabel);
            
            const yLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            yLabel.setAttribute('x', 5);
            yLabel.setAttribute('y', canvas.clientHeight / 2);
            yLabel.setAttribute('text-anchor', 'start');
            yLabel.setAttribute('transform', `rotate(-90, 5, ${canvas.clientHeight / 2})`);
            yLabel.setAttribute('transform-origin', `5 ${canvas.clientHeight / 2}`);
            yLabel.textContent = 'Loss L(W)';
            svg.appendChild(yLabel);
            
            // Draw minimum point
            const minPoint = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            minPoint.setAttribute('cx', scaleX(14));
            minPoint.setAttribute('cy', scaleY(lossFunction(14)));
            minPoint.setAttribute('r', '5');
            minPoint.setAttribute('fill', '#2ecc71');
            svg.appendChild(minPoint);
            
            // Label minimum point
            const minLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            minLabel.setAttribute('x', scaleX(14));
            minLabel.setAttribute('y', scaleY(lossFunction(14)) - 10);
            minLabel.setAttribute('text-anchor', 'middle');
            minLabel.textContent = 'Minimum (W=14)';
            svg.appendChild(minLabel);
        }
        
        function updateTable(iterations, currentIndex = -1) {
            const tableBody = document.getElementById('iterations-log');
            tableBody.innerHTML = '';
            
            iterations.forEach((it, index) => {
                const row = document.createElement('tr');
                if (index === currentIndex) {
                    row.className = 'highlight';
                }
                
                row.innerHTML = `
                    <td>${it.iteration}</td>
                    <td>${it.w.toFixed(4)}</td>
                    <td>${it.loss.toFixed(4)}</td>
                    <td>${it.gradient.toFixed(4)}</td>
                    <td>${it.absGradient.toFixed(4)}</td>
                `;
                
                tableBody.appendChild(row);
            });
        }
        
        function updateParameters(iteration) {
            document.getElementById('current-w').textContent = iteration.w.toFixed(4);
            document.getElementById('current-loss').textContent = iteration.loss.toFixed(4);
            document.getElementById('current-gradient').textContent = iteration.gradient.toFixed(4);
            document.getElementById('current-iteration').textContent = iteration.iteration;
        }
        
        // Initialize with example data
        let allIterations = [];
        let currentIndex = -1;
        let animationInterval = null;
        
        function runAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
            }
            
            currentIndex = 0;
            updateCharts();
            
            animationInterval = setInterval(() => {
                currentIndex++;
                if (currentIndex >= allIterations.length) {
                    clearInterval(animationInterval);
                    animationInterval = null;
                    return;
                }
                updateCharts();
            }, 500);
        }
        
        function updateCharts() {
            if (currentIndex >= 0 && currentIndex < allIterations.length) {
                updateParameters(allIterations[currentIndex]);
                drawLossChart(allIterations, currentIndex);
                drawFunctionChart(allIterations, currentIndex);
                updateTable(allIterations, currentIndex);
            }
        }
        
        function reset() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
            
            const learningRate = parseFloat(document.getElementById('learning-rate').value);
            const maxIterations = parseInt(document.getElementById('iterations').value);
            
            allIterations = gradientDescent(0, learningRate, maxIterations);
            currentIndex = -1;
            
            drawLossChart(allIterations);
            drawFunctionChart(allIterations);
            updateTable(allIterations);
            
            document.getElementById('current-w').textContent = "0.0000";
            document.getElementById('current-loss').textContent = "990.0000";
            document.getElementById('current-gradient').textContent = "-140.0000";
            document.getElementById('current-iteration').textContent = "0";
        }
        
        // Set up event listeners
        document.getElementById('run-btn').addEventListener('click', runAnimation);
        document.getElementById('reset-btn').addEventListener('click', reset);
        
        // Initialize on load
        window.addEventListener('load', () => {
            reset();
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            if (allIterations.length > 0) {
                drawLossChart(allIterations, currentIndex);
                drawFunctionChart(allIterations, currentIndex);
            }
        });
    </script>
</body>
</html>