<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Gradient Descent Algorithm Tutorial</title>
  <!-- Chart.js for beautiful charts -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      line-height: 1.6;
      color: #333;
      max-width: 1200px;
      margin: 0 auto;
      padding: 20px;
    }
    h1, h2, h3 {
      color: #2c3e50;
    }
    pre {
      background-color: #f5f5f5;
      padding: 15px;
      border-radius: 5px;
      overflow-x: auto;
    }
    code {
      font-family: 'Courier New', Courier, monospace;
    }
    .container {
      display: flex;
      flex-direction: row;
      gap: 20px;
      margin: 30px 0;
    }
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
    }
    .chart-container {
      flex: 1;
      height: 400px;
      border: 1px solid #ddd;
      border-radius: 5px;
      padding: 10px;
      min-width: 0;
      position: relative;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin: 20px 0;
    }
    @media (max-width: 640px) {
      .controls > div {
        width: 100%;
      }
    }
    button {
      padding: 8px 16px;
      background-color: #3498db;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background-color: #2980b9;
    }
    input {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    table {
      border-collapse: collapse;
      width: 100%;
      margin: 20px 0;
      overflow-x: auto;
      display: block;
    }
    @media (min-width: 768px) {
      table {
        display: table;
      }
    }
    th, td {
      border: 1px solid #ddd;
      padding: 8px;
      text-align: left;
    }
    th {
      background-color: #f2f2f2;
    }
    .highlight {
      background-color: #fffde7;
    }
    #iterations-table {
      max-height: 300px;
      overflow-y: auto;
    }
  </style>
</head>
<body>
  <h1>Gradient Descent Algorithm Visualization</h1>
  
  <p>
    This tutorial visualizes the gradient descent algorithm for finding the minimum of a quadratic function. 
    The example demonstrates how gradient descent iteratively approaches the optimal solution.
  </p>
  
  <div class="container">
    <!-- Soldaki grafik: Sadece Loss fonksiyonu, minimum, current position ve teğet -->
    <div class="chart-container">
      <canvas id="function-chart"></canvas>
    </div>
    <!-- Sağdaki grafik: İterasyon vs. Loss -->
    <div class="chart-container">
      <canvas id="loss-chart"></canvas>
    </div>
  </div>
  
  <div class="controls">
    <button id="run-btn">Run Gradient Descent</button>
    <button id="reset-btn">Reset</button>
    <div>
      <label for="learning-rate">Learning Rate:</label>
      <input type="number" id="learning-rate" min="0.001" max="1" step="0.001" value="0.05"/>
    </div>
    <div>
      <label for="iterations">Max Iterations:</label>
      <input type="number" id="iterations" min="1" max="100" value="50"/>
    </div>
  </div>
  
  <h2>Current Parameters</h2>
  <div id="parameters">
    <p>Weight (W): <span id="current-w">0</span></p>
    <p>Loss L(W): <span id="current-loss">0</span></p>
    <p>Gradient dL/dW: <span id="current-gradient">0</span></p>
    <p>Iteration: <span id="current-iteration">0</span></p>
  </div>
  
  <h2>Iterations Log</h2>
  <div id="iterations-table">
    <table>
      <thead>
        <tr>
          <th>Iteration</th>
          <th>Weight (W)</th>
          <th>Loss L(W)</th>
          <th>Gradient dL/dW</th>
          <th>|dL/dW|</th>
        </tr>
      </thead>
      <tbody id="iterations-log">
        <!-- Will be populated by JavaScript -->
      </tbody>
    </table>
  </div>
  
  <h2>How Gradient Descent Works</h2>
  
  <p>
    Gradient descent is an optimization algorithm used to minimize a function by iteratively moving in the direction of steepest descent 
    as defined by the negative of the gradient.
  </p>
  
  <h3>The Algorithm:</h3>
  <ol>
    <li>Start with an initial parameter value (weight)</li>
    <li>Calculate the gradient (derivative) of the loss function with respect to the parameter</li>
    <li>Update the parameter by moving in the opposite direction of the gradient</li>
    <li>Repeat until convergence</li>
  </ol>
  
  <h3>Implementation in JavaScript:</h3>
  <pre><code>// Function we want to minimize: L(W) = 5*(W-14)^2+10
function lossFunction(w) {
  return 5 * Math.pow(w - 14, 2) + 10;
}

// Derivative of the loss function: dL/dW = 10*(W-14)
function gradientFunction(w) {
  return 10 * (w - 14);
}

function gradientDescent(initialW, learningRate, maxIterations) {
  let w = initialW;
  let iterations = [];
  
  for (let i = 0; i < maxIterations; i++) {
    // Calculate current loss and gradient
    let loss = lossFunction(w);
    let gradient = gradientFunction(w);
    
    // Store current state
    iterations.push({
      iteration: i,
      w: w,
      loss: loss,
      gradient: gradient,
      absGradient: Math.abs(gradient)
    });
    
    // Stop if gradient is very small (convergence)
    if (Math.abs(gradient) < 0.001) {
      break;
    }
    
    // Update weight by moving in the opposite direction of the gradient
    w = w - learningRate * gradient;
  }
  
  return iterations;
}
  </code></pre>
  
  <h3>The Math Behind Our Example</h3>
  <p>In our example, we're minimizing the function:</p>
  <p><strong>L(W) = 5*(W-14)²+10</strong></p>
  
  <p>The derivative (gradient) is:</p>
  <p><strong>dL/dW = 10*(W-14)</strong></p>
  
  <p>For gradient descent, we update W using the rule:</p>
  <p><strong>W<sub>new</sub> = W<sub>old</sub> - learning_rate * gradient</strong></p>
  
  <p>This function has its minimum at W = 14, where the derivative equals zero:</p>
  <p><strong>10*(W-14) = 0</strong> gives <strong>W = 14</strong></p>
  
  <script>
    // The loss function: L(W) = 5*(W-14)^2+10
    function lossFunction(w) {
      return 5 * Math.pow(w - 14, 2) + 10;
    }
    
    // Derivative of the loss function: dL/dW = 10*(W-14)
    function gradientFunction(w) {
      return 10 * (w - 14);
    }
    
    // Gradient descent implementation
    function gradientDescent(initialW, learningRate, maxIterations) {
      let w = initialW;
      let iterations = [];
      
      for (let i = 0; i < maxIterations; i++) {
        let loss = lossFunction(w);
        let gradient = gradientFunction(w);
        
        iterations.push({
          iteration: i,
          w: w,
          loss: loss,
          gradient: gradient,
          absGradient: Math.abs(gradient)
        });
        
        if (Math.abs(gradient) < 0.001) {
          break;
        }
        
        w = w - learningRate * gradient;
      }
      
      return iterations;
    }
    
    // Chart.js chart instances
    let lossChart;
    let functionChart;
    
    // Initialize and draw the loss versus iterations chart (sağdaki grafik)
    function initLossChart() {
      const ctx = document.getElementById('loss-chart').getContext('2d');
      lossChart = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [],
          datasets: [
            {
              label: 'Loss L(W)',
              data: [],
              borderColor: '#3498db',
              backgroundColor: 'rgba(52, 152, 219, 0.1)',
              tension: 0.1,
              pointRadius: 4,
              pointHoverRadius: 6
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          plugins: {
            title: {
              display: true,
              text: 'Loss vs. Iterations',
              font: {
                size: 16,
                weight: 'bold'
              },
              padding: {
                top: 10,
                bottom: 10
              }
            },
            legend: {
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  return `Loss: ${context.parsed.y.toFixed(2)}`;
                }
              }
            }
          },
          scales: {
            x: {
              title: {
                display: true,
                text: 'Iterations'
              }
            },
            y: {
              title: {
                display: true,
                text: 'Loss L(W)'
              }
            }
          }
        }
      });
    }
    
    // Soldaki grafik: Sadece fonksiyon, minimum, current position ve tangent line
    // Burada x ekseni "linear" olarak ayarlandı ve data noktaları {x, y} formatında
    function initFunctionChart() {
      const minW = -5;
      const maxW = 20;
      const step = 0.5;
      
      // Fonksiyonun x,y değerlerini {x, y} olarak tutalım
      const functionData = [];
      for (let w = minW; w <= maxW; w += step) {
        functionData.push({ x: w, y: lossFunction(w) });
      }
      
      const ctx = document.getElementById('function-chart').getContext('2d');
      functionChart = new Chart(ctx, {
        type: 'line',
        data: {
          // labels kullanılmıyor, x: 'linear' eksenine geçiyoruz
          datasets: [
            {
              label: 'Loss Function L(W)',
              data: functionData, // { x, y } noktaları
              borderColor: '#3498db',
              backgroundColor: 'rgba(52, 152, 219, 0.1)',
              borderWidth: 2,
              pointRadius: 0,
              fill: false
            },
            {
              label: 'Current Position',
              data: [],
              borderColor: '#e67e22',
              pointRadius: 6,
              pointBackgroundColor: '#e67e22',
              showLine: false
            },
            {
              label: 'Tangent Line',
              data: [],
              borderColor: '#e67e22',
              borderWidth: 2,
              borderDash: [5, 5],
              pointRadius: 0,
              fill: false
            },
            {
              label: 'Minimum',
              data: [{ x: 14, y: lossFunction(14) }],
              borderColor: '#2ecc71',
              backgroundColor: '#2ecc71',
              pointRadius: 6,
              showLine: false
            }
          ]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: { duration: 0 },
          plugins: {
            title: {
              display: true,
              text: 'Loss Function L(W) = 5*(W-14)²+10',
              font: {
                size: 16,
                weight: 'bold'
              },
              padding: {
                top: 10,
                bottom: 10
              }
            },
            legend: {
              position: 'top'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  if (context.dataset.label === 'Minimum') {
                    return 'Minimum Point (W=14)';
                  }
                  const xVal = context.parsed.x.toFixed(2);
                  const yVal = context.parsed.y.toFixed(2);
                  return `${context.dataset.label}: (W=${xVal}, L=${yVal})`;
                }
              }
            }
          },
          scales: {
            x: {
              type: 'linear',
              min: minW,
              max: maxW,
              title: {
                display: true,
                text: 'Weight (W)'
              }
            },
            y: {
              title: {
                display: true,
                text: 'Loss L(W)'
              }
            }
          }
        }
      });
    }
    
    // Update charts with new iteration data
    function updateCharts(iterations, currentIndex) {
      if (!iterations || iterations.length === 0) return;
      
      // Sağdaki grafik: Loss vs Iteration
      const iterationLabels = iterations.map(it => it.iteration);
      const lossValues = iterations.map(it => it.loss);
      
      // Güncelleme
      lossChart.data.labels = iterationLabels;
      lossChart.data.datasets[0].data = lossValues;
      
      // Highlight current point on the loss chart
      if (currentIndex >= 0 && currentIndex < iterations.length) {
        lossChart.data.datasets[0].pointBackgroundColor = iterationLabels.map((_, i) =>
          i === currentIndex ? '#e74c3c' : '#3498db'
        );
        lossChart.data.datasets[0].pointRadius = iterationLabels.map((_, i) =>
          i === currentIndex ? 6 : 4
        );
      }
      lossChart.update();
      
      // Soldaki grafik: sadece current position + tangent line (gradient) göstereceğiz
      if (currentIndex >= 0 && currentIndex < iterations.length) {
        const w = iterations[currentIndex].w;
        const loss = iterations[currentIndex].loss;
        const gradient = iterations[currentIndex].gradient;
        
        // Geçerli nokta
        const currentPos = { x: w, y: loss };
        functionChart.data.datasets[1].data = [currentPos];
        
        // Teğet çizgi
        const tangentLength = 3;
        const x1 = Math.max(-5, w - tangentLength);
        const x2 = Math.min(20, w + tangentLength);
        
        // y = L(w) +/- gradient * delta
        const y1 = loss - gradient * (w - x1);
        const y2 = loss + gradient * (x2 - w);
        
        functionChart.data.datasets[2].data = [
          { x: x1, y: y1 },
          { x: x2, y: y2 }
        ];
        
        // Annotation (isteğe bağlı)
        functionChart.options.plugins.annotation = {
          annotations: {
            gradientLabel: {
              type: 'label',
              xValue: w + 0.5,
              yValue: loss - 50,
              content: [`Gradient: ${gradient.toFixed(2)}`],
              font: {
                size: 12
              },
              color: '#e67e22'
            }
          }
        };
      } else {
        // Hiçbir iterasyon yoksa veya index geçersizse temizle
        functionChart.data.datasets[1].data = [];
        functionChart.data.datasets[2].data = [];
      }
      
      functionChart.update();
    }
    
    function updateTable(iterations, currentIndex = -1) {
      const tableBody = document.getElementById('iterations-log');
      tableBody.innerHTML = '';
      
      iterations.forEach((it, index) => {
        const row = document.createElement('tr');
        if (index === currentIndex) {
          row.className = 'highlight';
        }
        row.innerHTML = `
          <td>${it.iteration}</td>
          <td>${it.w.toFixed(4)}</td>
          <td>${it.loss.toFixed(4)}</td>
          <td>${it.gradient.toFixed(4)}</td>
          <td>${it.absGradient.toFixed(4)}</td>
        `;
        tableBody.appendChild(row);
      });
    }
    
    function updateParameters(iteration) {
      document.getElementById('current-w').textContent = iteration.w.toFixed(4);
      document.getElementById('current-loss').textContent = iteration.loss.toFixed(4);
      document.getElementById('current-gradient').textContent = iteration.gradient.toFixed(4);
      document.getElementById('current-iteration').textContent = iteration.iteration;
    }
    
    // Genel değişkenler
    let allIterations = [];
    let currentIndex = -1;
    let animationInterval = null;
    
    // Animasyonu başlat
    function runAnimation() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
      }
      currentIndex = 0;
      updateCharts(allIterations, currentIndex);
      updateTable(allIterations, currentIndex);
      updateParameters(allIterations[currentIndex]);
      
      animationInterval = setInterval(() => {
        currentIndex++;
        if (currentIndex >= allIterations.length) {
          clearInterval(animationInterval);
          animationInterval = null;
          return;
        }
        updateCharts(allIterations, currentIndex);
        updateTable(allIterations, currentIndex);
        updateParameters(allIterations[currentIndex]);
      }, 500);
    }
    
    // Reset ve yeniden başlat
    function reset() {
      if (animationInterval) {
        clearInterval(animationInterval);
        animationInterval = null;
      }
      const learningRate = parseFloat(document.getElementById('learning-rate').value);
      const maxIterations = parseInt(document.getElementById('iterations').value);
      
      allIterations = gradientDescent(0, learningRate, maxIterations);
      currentIndex = -1;
      
      const initialIteration = allIterations[0];
      document.getElementById('current-w').textContent = initialIteration.w.toFixed(4);
      document.getElementById('current-loss').textContent = initialIteration.loss.toFixed(4);
      document.getElementById('current-gradient').textContent = initialIteration.gradient.toFixed(4);
      document.getElementById('current-iteration').textContent = initialIteration.iteration;
      
      updateCharts(allIterations, -1);
      updateTable(allIterations);
    }
    
    document.getElementById('run-btn').addEventListener('click', runAnimation);
    document.getElementById('reset-btn').addEventListener('click', reset);
    
    // Sayfa yüklenince grafikleri kur ve resetle
    window.addEventListener('load', () => {
      initLossChart();
      initFunctionChart();
      reset();
    });
  </script>
</body>
</html>
