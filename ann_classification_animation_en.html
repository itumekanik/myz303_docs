<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MNIST Neural Network Animation</title>
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet" />
  <!-- Prism.js CSS for Syntax Highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" />
  <style>
    /* Variables and Basic Settings */
    :root {
      --primary-color: #3498db;
      --primary-hover: #2980b9;
      --accent-color: #ff6b6b;
      --bg-color: #f5f5f5;
      --card-bg: #ffffff;
      --text-color: #333;
      --box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
      --transition-speed: 0.3s;

      /* Pixel sizes */
      --pixel-size: 20px;
      /* Pixel box size for input digits */
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: 'Inter', sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 1200px;
      margin: 0 auto;
      background-color: var(--card-bg);
      box-shadow: var(--box-shadow);
      border-radius: 10px;
      padding: 30px;
    }

    header h1 {
      text-align: center;
      margin-bottom: 20px;
      font-size: 2rem;
      color: #2c3e50;
    }

    /* Input Digit Area */
    .input-image {
      display: flex;
      flex-direction: column;
      align-items: center;
      margin-bottom: 30px;
    }

    .input-image h3 {
      margin-bottom: 12px;
      font-size: 1.3rem;
      color: #2c3e50;
    }

    .digit-grid {
      display: grid;
      grid-template-columns: repeat(7, var(--pixel-size));
      grid-template-rows: repeat(7, var(--pixel-size));
      gap: 2px;
      margin-bottom: 15px;
    }

    .pixel {
      width: var(--pixel-size);
      height: var(--pixel-size);
      background-color: #ddd;
      border-radius: 2px;
    }

    .pixel.active {
      background-color: #333;
    }

    .current-digit {
      font-size: 2.2rem;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Network (Layers) Area */
    .network-container {
      position: relative;
      height: 500px;
      margin: 40px 0;
    }

    .layer {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      z-index: 10;
    }

    .layer-info {
      background-color: rgba(240, 240, 240, 0.9);
      border-radius: 5px;
      padding: 8px 12px;
      margin-bottom: 12px;
      font-weight: 600;
    }

    .neurons-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: rgba(240, 240, 240, 0.8);
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 10px;
    }

    .neuron {
      width: 18px;
      height: 18px;
      margin: 3px;
      border-radius: 50%;
      background-color: #e0e0e0;
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }

    .neuron.active {
      background-color: var(--accent-color);
      transform: scale(1.3);
    }

    .neuron.input {
      background-color: #74b9ff;
    }

    .neuron.output {
      background-color: #55efc4;
    }

    .activation-function {
      margin-top: 5px;
      font-size: 0.9rem;
      font-weight: 600;
      opacity: 0.8;
    }

    /* Connections between layers (SVG) */
    .svg-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    svg {
      width: 100%;
      height: 100%;
    }

    .connection {
      stroke: #999;
      stroke-opacity: 0.1;
      transition: stroke var(--transition-speed), stroke-opacity var(--transition-speed);
    }

    .connection.active {
      stroke: var(--accent-color);
      stroke-opacity: 0.7;
      stroke-width: 1.5;
    }

    /* Output Display */
    .output-display {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 20px;
      position: relative;
      margin-top: 30px;
    }

    .digit-container {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .output-digit {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background-color: #e0e0e0;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 1rem;
      transition: background-color var(--transition-speed), transform var(--transition-speed);
    }

    .output-digit.active {
      background-color: var(--accent-color);
      color: #fff;
      transform: scale(1.2);
    }

    .probability-bar {
      width: 40px;
      background-color: #e0e0e0;
      transition: height 0.5s, background-color 0.5s;
      margin-top: 5px;
    }

    .probability-bar.active {
      background-color: var(--accent-color);
    }

    .probability-value {
      font-size: 0.9rem;
      margin-top: 5px;
      font-weight: 500;
    }

    /* Prediction Result */
    .prediction-result {
      text-align: center;
      font-size: 1.4rem;
      font-weight: 600;
      padding: 18px;
      background-color: #f0f8ff;
      border-radius: 8px;
      margin-top: 40px;
      opacity: 0;
      transition: opacity 1s;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .prediction-result.show {
      opacity: 1;
    }

    .result-overlay {
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 3rem;
      font-weight: 700;
      color: var(--accent-color);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
      animation: popIn 0.5s ease-out;
    }

    @keyframes popIn {
      0% {
        transform: scale(0);
        opacity: 0;
      }

      60% {
        transform: scale(1.2);
        opacity: 1;
      }

      100% {
        transform: scale(1);
        opacity: 1;
      }
    }

    /* Control Panel (Buttons) */
    .control-panel {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 20px;
      margin-top: 40px;
    }

    button {
      padding: 12px 28px;
      background-color: var(--primary-color);
      color: #fff;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color var(--transition-speed), transform 0.2s;
      font-weight: 600;
    }

    button:hover {
      background-color: var(--primary-hover);
      transform: translateY(-2px);
    }

    button:active {
      transform: translateY(1px);
    }

    /* Explanation Section */
    .explanation {
      margin-top: 40px;
      padding: 25px;
      background-color: #f5f9fc;
      border-radius: 10px;
      line-height: 1.7;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }

    .explanation h3 {
      margin-bottom: 15px;
      font-size: 1.4rem;
      color: #2c3e50;
      border-bottom: 2px solid #e1e8ed;
      padding-bottom: 8px;
    }

    .explanation p {
      margin-bottom: 15px;
    }

    .explanation ul {
      margin-bottom: 15px;
      padding-left: 25px;
    }

    .explanation li {
      margin-bottom: 8px;
    }

    /* For additional headings */
    .explanation h4 {
      margin-top: 30px;
      margin-bottom: 15px;
      font-size: 1.2rem;
      font-weight: 600;
      color: #2c3e50;
    }

    /* Special styles for Python code blocks */
    pre[class*="language-"] {
      margin: 20px 0;
      border-radius: 6px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    }

    code[class*="language-"] {
      font-size: 0.95rem;
      line-height: 1.5;
    }

    .token.comment {
      color: #75715e;
      font-style: italic;
    }

    .token.keyword {
      color: #f92672;
    }

    .token.string {
      color: #a6e22e;
    }

    .token.function {
      color: #66d9ef;
    }

    .token.class-name {
      color: #a6e22e;
    }

    /* Footer */
    footer p {
      text-align: center;
      font-size: 0.9rem;
      opacity: 0.8;
      margin-top: 40px;
      padding-top: 15px;
      border-top: 1px solid #e1e8ed;
    }

    /* For highlighting Python explanations */
    .code-comment {
      color: #6a9955;
      font-style: italic;
    }

    .highlight {
      background-color: rgba(255, 255, 0, 0.1);
      padding: 1px 2px;
      border-radius: 3px;
    }

    /* Responsive design */
    @media (max-width: 768px) {
      .container {
        padding: 15px;
      }

      header h1 {
        font-size: 1.6rem;
      }

      .explanation {
        padding: 15px;
      }

      pre[class*="language-"] {
        font-size: 0.85rem;
      }
    }
  </style>
</head>

<body>
  <div class="container">
    <header>
      <h1>MNIST Neural Network Animation</h1>
    </header>

    <main>
      <!-- Input Digit -->
      <section class="input-image">
        <h3>Input Digit</h3>
        <div class="digit-grid" id="digitGrid"></div>
        <div class="current-digit" id="currentDigit">3</div>
      </section>

      <!-- Network Structure (Layers + Connections) -->
      <section class="network-container" id="networkContainer">
        <div class="svg-container" id="svgContainer">
          <svg id="connectionsSvg"></svg>
        </div>
        <!-- Layers will be added dynamically via JS -->
      </section>

      <!-- Output Display -->
      <section class="output-display" id="outputDisplay">
        <!-- Output digits 0-9 and probability bars will be added via JS -->
      </section>

      <!-- Prediction Result -->
      <section id="predictionResult" class="prediction-result">
        Prediction: <span id="predictedDigit">3</span> (Confidence: <span id="confidence">92%</span>)
      </section>

      <!-- Control Buttons -->
      <section class="control-panel">
        <button id="restartBtn">Restart Animation</button>
        <button id="changeDigitBtn">Change Digit</button>
      </section>

      <!-- Explanation and New Chapter -->
      <section class="explanation">
        <h3>How Does MNIST Neural Network Work?</h3>
        <p>This animation demonstrates how a neural network recognizes a handwritten digit. The model consists of 4 layers:</p>
        <ul>
          <li><strong>Input Layer:</strong> 28x28 pixel handwritten image is converted into a vector of 784 neurons.</li>
          <li><strong>Hidden Layers:</strong> Contains 512, 256, and 128 neurons respectively, and each layer processes information from the previous layer.</li>
          <li><strong>Output Layer:</strong> Contains 10 neurons, each representing digits 0-9.</li>
        </ul>
        <p>Between each layer, <strong>ReLU</strong> is used, and in the final layer <strong>log_softmax</strong> activation function is used. <em>log_softmax</em> is the logarithm of the softmax function. The softmax function converts outputs to probability values between 0 and 1, and their sum equals 1. This process is used to determine which digit has the highest probability.</p>
        <p>In the animation, active neurons are shown in red, and important connections are highlighted. Additionally, the probability of each digit is represented with a bar, and the digit with the highest probability is shown as the "prediction".</p>

        <!-- New Chapter: Python Code and Explanations -->
        <h4>Python Code and Explanations</h4>
        <p>Below is an example of a simple fully connected neural network (MNISTNet) written with PyTorch and line-by-line explanations. This code takes 28x28 MNIST images (784 pixels) as input, passes them through three hidden layers, and returns logarithmic probability values for 10 different digits (0-9).</p>

        <pre><code class="language-python">import torch
import torch.nn as nn           # PyTorch's basic neural network modules
import torch.nn.functional as F # Activation functions and other helper functions

class MNISTNet(nn.Module):
    """
    MNISTNet is a simple fully connected neural network architecture
    designed for the MNIST dataset.
    """
    def __init__(self):
        # Calling the initializer of the nn.Module class
        super(MNISTNet, self).__init__()

        # Input layer: 28x28 pixels -> vector of size 784
        # 1st Hidden layer: 784 -> 512
        self.fc1 = nn.Linear(784, 512)

        # 2nd Hidden layer: 512 -> 256
        self.fc2 = nn.Linear(512, 256)

        # 3rd Hidden layer: 256 -> 128
        self.fc3 = nn.Linear(256, 128)

        # Output layer: 128 -> 10 (digit classes from 0 to 9)
        self.fc4 = nn.Linear(128, 10)

        # Dropout layer to reduce overfitting (dropout rate 20%)
        self.dropout = nn.Dropout(0.2)

    def forward(self, x):
        """
        In the forward pass method, we define the sequence in which data is passed through the network.
        x: MNIST images in the shape [batch_size, 1, 28, 28]
        """
        # 1) Flatten the input data: [batch_size, 784]
        x = x.view(-1, 28 * 28)

        # 2) First layer + ReLU activation
        x = F.relu(self.fc1(x))
        # Apply dropout to disable certain neurons
        x = self.dropout(x)

        # 3) Second layer + ReLU activation
        x = F.relu(self.fc2(x))
        x = self.dropout(x)

        # 4) Third layer + ReLU activation
        x = F.relu(self.fc3(x))
        x = self.dropout(x)

        # 5) Output layer
        x = self.fc4(x)

        # 6) Converting output values to probability distribution with log_softmax
        # dim=1: calculates log_softmax row-wise (for each example)
        return F.log_softmax(x, dim=1)</code></pre>

        <p>During the training of this model, a cross-entropy-like loss function (e.g. <code>nn.NLLLoss</code> or <code>nn.CrossEntropyLoss</code>) is used. When training is complete, the model produces a "prediction" (the digit with the highest probability) for each input image.</p>
      </section>
    </main>

    <footer>
      <p>© 2025 MNIST Animation Example</p>
    </footer>
  </div>

  <!-- CSS and JS for Prism.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>

  <script>
    // Code that will run after the page is fully loaded
    window.onload = function () {
      // Network configuration
      const networkConfig = {
        layers: [
          { name: "Input (784)", neurons: 10, fullSize: 784, activationFunc: "" },
          { name: "Hidden 1 (512)", neurons: 8, fullSize: 512, activationFunc: "ReLU" },
          { name: "Hidden 2 (256)", neurons: 6, fullSize: 256, activationFunc: "ReLU" },
          { name: "Hidden 3 (128)", neurons: 5, fullSize: 128, activationFunc: "ReLU" },
          { name: "Output (10)", neurons: 10, fullSize: 10, activationFunc: "log_softmax" }
        ]
      };

      // Sample digits
      const sampleDigits = [3, 7, 2, 5, 0, 1, 9, 8];
      let currentDigitIndex = 0;

      // 7x7 pixel patterns
      const digitPatterns = {
        0: [
          [0, 1, 1, 1, 1, 1, 0],
          [1, 1, 0, 0, 0, 1, 1],
          [1, 1, 0, 0, 0, 1, 1],
          [1, 1, 0, 0, 0, 1, 1],
          [1, 1, 0, 0, 0, 1, 1],
          [1, 1, 0, 0, 0, 1, 1],
          [0, 1, 1, 1, 1, 1, 0]
        ],
        1: [
          [0, 0, 1, 1, 0, 0, 0],
          [0, 1, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ],
        2: [
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 1, 1, 0, 0, 0, 0],
          [1, 1, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 1, 0]
        ],
        3: [
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [0, 0, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ],
        5: [
          [1, 1, 1, 1, 1, 1, 0],
          [1, 1, 0, 0, 0, 0, 0],
          [1, 1, 0, 0, 0, 0, 0],
          [1, 1, 1, 1, 1, 0, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ],
        7: [
          [1, 1, 1, 1, 1, 1, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [0, 0, 0, 1, 1, 0, 0],
          [0, 0, 1, 1, 0, 0, 0],
          [0, 1, 1, 0, 0, 0, 0],
          [0, 1, 1, 0, 0, 0, 0],
          [0, 1, 1, 0, 0, 0, 0]
        ],
        8: [
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ],
        9: [
          [0, 1, 1, 1, 1, 0, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 1, 0],
          [0, 0, 0, 0, 1, 1, 0],
          [1, 1, 0, 0, 1, 1, 0],
          [0, 1, 1, 1, 1, 0, 0]
        ]
      };

      // DOM references
      const digitGrid = document.getElementById('digitGrid');
      const currentDigitElem = document.getElementById('currentDigit');
      const outputDisplay = document.getElementById('outputDisplay');
      const networkContainer = document.getElementById('networkContainer');
      const restartBtn = document.getElementById('restartBtn');
      const changeDigitBtn = document.getElementById('changeDigitBtn');

      let connections = [];
      let animationTimeouts = [];

      /* ========== Input Digit (7x7 Pixels) ========== */
      function createDigitGrid() {
        digitGrid.innerHTML = '';
        const digit = sampleDigits[currentDigitIndex];
        const pattern = digitPatterns[digit];
        for (let i = 0; i < 7; i++) {
          for (let j = 0; j < 7; j++) {
            const pixel = document.createElement('div');
            pixel.className = 'pixel';
            if (pattern[i][j] === 1) {
              pixel.classList.add('active');
            }
            digitGrid.appendChild(pixel);
          }
        }
        currentDigitElem.textContent = digit;
      }

      /* ========== Output (Probabilities) ========== */
      function createOutputDisplay() {
        outputDisplay.innerHTML = '';
        for (let i = 0; i < 10; i++) {
          const digitContainer = document.createElement('div');
          digitContainer.className = 'digit-container';

          const digitElem = document.createElement('div');
          digitElem.className = 'output-digit';
          digitElem.id = `output-${i}`;
          digitElem.textContent = i;
          digitContainer.appendChild(digitElem);

          const probBar = document.createElement('div');
          probBar.className = 'probability-bar';
          probBar.id = `prob-bar-${i}`;
          digitContainer.appendChild(probBar);

          const probValue = document.createElement('div');
          probValue.className = 'probability-value';
          probValue.id = `prob-value-${i}`;
          probValue.textContent = '0%';
          digitContainer.appendChild(probValue);

          outputDisplay.appendChild(digitContainer);
        }
      }

      /* ========== Creating Network (Layers + Connections) ========== */
      function createNeuralNetwork() {
        networkContainer.innerHTML = '';

        // Container for SVG
        const svgContainer = document.createElement('div');
        svgContainer.className = 'svg-container';
        svgContainer.id = 'svgContainer';
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.id = 'connectionsSvg';
        svgContainer.appendChild(svg);
        networkContainer.appendChild(svgContainer);

        // Placing layers
        networkConfig.layers.forEach((layerConfig, layerIndex) => {
          const layer = document.createElement('div');
          layer.className = 'layer';
          layer.id = `layer-${layerIndex}`;

          // Positioning layers horizontally with equal spacing
          const containerWidth = networkContainer.clientWidth;
          const layerSpacing = containerWidth / (networkConfig.layers.length + 1);
          layer.style.left = `${layerSpacing * (layerIndex + 1)}px`;

          // Layer header
          const layerInfo = document.createElement('div');
          layerInfo.className = 'layer-info';
          layerInfo.textContent = layerConfig.name;
          layer.appendChild(layerInfo);

          // Neurons
          const neuronsContainer = document.createElement('div');
          neuronsContainer.className = 'neurons-container';
          for (let i = 0; i < layerConfig.neurons; i++) {
            const neuron = document.createElement('div');
            neuron.className = 'neuron';
            neuron.id = `neuron-${layerIndex}-${i}`;
            if (layerIndex === 0) {
              neuron.classList.add('input');
            } else if (layerIndex === networkConfig.layers.length - 1) {
              neuron.classList.add('output');
            }
            neuronsContainer.appendChild(neuron);
          }
          layer.appendChild(neuronsContainer);

          // Activation function label
          if (layerConfig.activationFunc && layerConfig.activationFunc !== "log_softmax") {
            const activation = document.createElement('div');
            activation.className = 'activation-function';
            activation.textContent = layerConfig.activationFunc;
            layer.appendChild(activation);
          }

          networkContainer.appendChild(layer);
        });
        // Create connections
        createConnections();
      }

      function createConnections() {
        const svg = document.getElementById('connectionsSvg');
        svg.innerHTML = '';
        connections = [];

        for (let l = 0; l < networkConfig.layers.length - 1; l++) {
          const sourceLayer = document.getElementById(`layer-${l}`);
          const targetLayer = document.getElementById(`layer-${l + 1}`);
          const sourceNeurons = sourceLayer.querySelectorAll('.neuron');
          const targetNeurons = targetLayer.querySelectorAll('.neuron');

          sourceNeurons.forEach((sourceNeuron, si) => {
            const sourceRect = sourceNeuron.getBoundingClientRect();
            const containerRect = networkContainer.getBoundingClientRect();

            targetNeurons.forEach((targetNeuron, ti) => {
              const targetRect = targetNeuron.getBoundingClientRect();
              const x1 = sourceRect.left + sourceRect.width / 2 - containerRect.left;
              const y1 = sourceRect.top + sourceRect.height / 2 - containerRect.top;
              const x2 = targetRect.left + targetRect.width / 2 - containerRect.left;
              const y2 = targetRect.top + targetRect.height / 2 - containerRect.top;

              const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
              line.setAttribute('x1', x1);
              line.setAttribute('y1', y1);
              line.setAttribute('x2', x2);
              line.setAttribute('y2', y2);
              line.setAttribute('class', 'connection');
              line.id = `connection-${l}-${si}-${l + 1}-${ti}`;
              svg.appendChild(line);

              connections.push({
                sourceLayer: l,
                sourceNeuron: si,
                targetLayer: l + 1,
                targetNeuron: ti,
                element: line
              });
            });
          });
        }
      }

      /* ========== Animation (Forward Propagation) ========== */
      function runForwardPassAnimation() {
        clearActivations();

        const neuronDelay = 400;
        const layerDelay = 800;
        const inputNeurons = document.querySelectorAll('#layer-0 .neuron');
        const currentDigit = sampleDigits[currentDigitIndex];

        // Input layer activation
        setTimeout(() => {
          const activeNeuronCount = Math.floor(Math.random() * 2) + 3;
          const activeIndices = new Set();
          while (activeIndices.size < activeNeuronCount) {
            const randIndex = Math.floor(Math.random() * inputNeurons.length);
            activeIndices.add(randIndex);
          }
          activeIndices.forEach(idx => {
            inputNeurons[idx].classList.add('active');
          });
        }, 500);

        // Transition between layers
        for (let l = 0; l < networkConfig.layers.length - 1; l++) {
          setTimeout(() => {
            const sourceNeurons = document.querySelectorAll(`#layer-${l} .neuron.active`);
            const targetLayer = l + 1;

            sourceNeurons.forEach(sourceNeuron => {
              const sourceIndex = parseInt(sourceNeuron.id.split('-')[2]);
              const relevantConnections = connections.filter(
                conn => conn.sourceLayer === l && conn.sourceNeuron === sourceIndex
              );
              relevantConnections.forEach(conn => {
                conn.element.classList.add('active');
              });

              // Random target neuron activation
              setTimeout(() => {
                const targetNeurons = document.querySelectorAll(`#layer-${targetLayer} .neuron`);
                const neuronCount = Math.min(targetNeurons.length, Math.floor(Math.random() * 2) + 2);
                const activeIndices = new Set();
                while (activeIndices.size < neuronCount) {
                  const randIndex = Math.floor(Math.random() * targetNeurons.length);
                  activeIndices.add(randIndex);
                }
                activeIndices.forEach(idx => {
                  targetNeurons[idx].classList.add('active');
                });
              }, neuronDelay);
            });
          }, layerDelay * (l + 1));
        }

        // Final layer (softmax results)
        setTimeout(() => {
          const probabilities = generateSoftmaxProbabilities(currentDigit);
          updateProbabilityBars(probabilities);

          const predictedDigit = currentDigit;
          const outputDigit = document.getElementById(`output-${predictedDigit}`);
          if (outputDigit) {
            outputDigit.classList.add('active');
          }
          const lastLayerIndex = networkConfig.layers.length - 1;
          const allOutputNeurons = document.querySelectorAll(`#layer-${lastLayerIndex} .neuron`);
          allOutputNeurons.forEach(neuron => {
            neuron.classList.add('output');
          });
          const outputNeuron = document.getElementById(`neuron-${lastLayerIndex}-${predictedDigit}`);
          if (outputNeuron) {
            outputNeuron.classList.add('active');
            outputNeuron.classList.remove('output');
          }
          document.getElementById('predictedDigit').textContent = predictedDigit;
          document.getElementById('confidence').textContent = `${Math.round(probabilities[predictedDigit] * 100)}%`;
          document.getElementById('predictionResult').classList.add('show');

          const resultOverlay = document.createElement('div');
          resultOverlay.className = 'result-overlay';
          resultOverlay.textContent = predictedDigit;
          networkContainer.appendChild(resultOverlay);
        }, layerDelay * networkConfig.layers.length);
      }

      /* ========== Softmax Simulation ========== */
      function generateSoftmaxProbabilities(correctDigit) {
        const probabilities = Array(10).fill(0).map(() => Math.random() * 0.1);
        probabilities[correctDigit] = 0.7 + Math.random() * 0.25;
        const sum = probabilities.reduce((a, b) => a + b, 0);
        return probabilities.map(p => p / sum);
      }

      function updateProbabilityBars(probabilities) {
        probabilities.forEach((prob, index) => {
          const bar = document.getElementById(`prob-bar-${index}`);
          const value = document.getElementById(`prob-value-${index}`);
          if (bar && value) {
            const height = prob * 100;
            bar.style.height = `${height}px`;
            value.textContent = `${Math.round(prob * 100)}%`;
            if (prob > 0.1) {
              bar.classList.add('active');
            } else {
              bar.classList.remove('active');
            }
          }
        });
      }

      /* ========== Cleanup ========== */
      function clearActivations() {
        document.querySelectorAll('.neuron').forEach(neuron => {
          neuron.classList.remove('active');
        });
        document.querySelectorAll('.connection').forEach(conn => {
          conn.classList.remove('active');
        });
        document.querySelectorAll('.output-digit').forEach(digit => {
          digit.classList.remove('active');
        });
        document.querySelectorAll('.probability-bar').forEach(bar => {
          bar.style.height = '0';
          bar.classList.remove('active');
        });
        document.querySelectorAll('.probability-value').forEach(value => {
          value.textContent = '0%';
        });
        document.getElementById('predictionResult').classList.remove('show');
        const resultOverlay = document.querySelector('.result-overlay');
        if (resultOverlay) {
          resultOverlay.remove();
        }
        animationTimeouts.forEach(timeout => clearTimeout(timeout));
        animationTimeouts = [];
      }

      /* ========== Event Listeners ========== */
      window.addEventListener('resize', createConnections);

      restartBtn.addEventListener('click', () => {
        clearActivations();
        setTimeout(runForwardPassAnimation, 100);
      });

      changeDigitBtn.addEventListener('click', () => {
        currentDigitIndex = (currentDigitIndex + 1) % sampleDigits.length;
        createDigitGrid();
        clearActivations();
        setTimeout(runForwardPassAnimation, 300);
      });

      // Run Prism.js for code highlighting
      if (typeof Prism !== 'undefined') {
        Prism.highlightAll();
      }

      // Create animation and start at page load
      createNeuralNetwork();
      createDigitGrid();
      createOutputDisplay();

      // Start animation
      setTimeout(runForwardPassAnimation, 1000);
    };
  </script>
</body>

</html>